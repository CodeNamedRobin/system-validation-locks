% OTHER IDEA FOR SORT WITH THE SAME ELEMENTS IN THE STRUCT
sort WaterLevel = struct top | between | bottom;
	 LightColor = struct red | green;
	 GateStatus = struct open | opening | closed | closing | stopped;
	 BoatMoving = struct enter | exit | none;
	 BoatPresent = struct downBoat | upBoat | empty;
	 LockNr = struct 1 | 2;
	 LockBusy = struct available | busy;

% all actions are associated with a gate
% the four lights are of type LightColor
% the communication actions between lock and boatcontroller are of type BoatMoving

act light_TO, light_TI, light_BO, light_BI, sendTOLight, receiveTOLight, sendBOLight, receiveBOLight, turnOnTO, turnOffTO: LightColor;
	sendDownBoatRequest, receiveDownBoatRequest, sendUpBoatRequest, receiveUpBoatRequest, commDownBoat, commUpBoat: BoatMoving;
	startOpenTopGate, startCloseTopGate, startOpenBottomGate, startCloseBottomGate, arriveTop, arriveBottom, controlDownBoatEnter, receiveDownBoatEnter, controlDBEnter, downBoatEnter, upBoatEnter, downBoatExit, upBoatExit, upBoatEntered, downBoatEntered, bottomGateClosed, topGateClosed, bottomGateOpened, topGateOpened, startOpenCulvert, culvertOpened, startCloseCulvert, culvertClosed, detectWaterBottom, detectWaterTop;
	
% Lock process depends on:
% waterlevel
% what kind of boat is in the lock (if any)
% is top/bottom gate open/closed/opening/closing/sttopped
% what is the color of the lights
% is a boat moving through a gate at top/bottom gate

proc Lock(i:LockNr, w_level:WaterLevel, boat_present:BoatPresent, top_g_status:GateStatus, bottom_g_status:GateStatus, top_o_light:LightColor, top_i_light:LightColor, bottom_o_light:LightColor, bottom_i_light:LightColor, top_boat_moving:BoatMoving, bottom_boat_moving:BoatMoving, paddle_status:GateStatus, culvert_status:GateStatus) = 
	(boat_present == emtpy) % able to receive a boat
		-> sum request:BoatMoving.receiveDownBoatRequest(i, request).
			((request == enter && top_o_light == green)
				-> receiveDownBoatEnter.light_TO(red).Lock(top_boat_moving = enter, top_o_light = red))
			+ sendAvailable(i).
	% boat_present != empty)
	<> (boat_present == downBoat)
		-> (top_boat_moving == enter)
			-> downBoatEntered.Lock(top_boat_moving == none) % boat is in the lock
		<> (top_boat_moving == none && top_g_status == open)
			-> startCloseTopGate.Lock(top_g_status = closing) % start closing the gate
		<> (top_g_status == closing) 
			-> topGateClosed.Lock(top_g_status = closed) % top gate is closed
		<> (top_g_status == closed && paddle_status == closed)
			-> startOpenPaddle.Lock(paddle_status = opening, w_level = between) % open paddle to lower water
		<> (paddle_status == opening)
			-> paddleOpened.Lock(paddle_status = open)
		<> (paddle_status == open && w_level == between)
			-> detectWaterBottom.Lock(w_level = bottom)
		<> (w_level == bottom && paddle_status == open)
			-> startClosePaddle.Lock(paddle_status = closing)
		<> (w_level == bottom && paddle_status == closing)
			-> paddleClosed.Lock(paddle_status = closed)
		<> (w_level == bottom && paddle_status == closed && bottom_g_status == closed) % let the downBoat out
			-> startOpenBottomGate.Lock(bottom_g_status = opening)
		<> (bottom_g_status == opening)
			-> bottomGateOpened.Lock(bottom_g_status = open)
		<> (bottom_g_status == open && bottom_i_light == red)
			-> light_BI(green).Lock(bottom_i_light = green)
		<> (bottom_i_light == green)
			-> downBoatExit.light_BI(red).Lock(bottom_boat_moving = exit, bottom_i_light = red)
		<> (bottom_boat_moving == exit)
			-> downBoatExited.Lock(boat_present = empty)
	<> (boat_present == upBoat)
		-> (bottom_boat_moving == enter)
			-> upBoatEntered.Lock(bottom_boat_moving = none)
		<> (bottom_boat_moving == none && bottom_g_status == open)
			-> startCloseBottomGate.Lock(bottom_g_status = closing)
		<> (bottom_g_status == closing)
			-> bottomGateClosed.Lock(bottom_g_status = closed)
		<> (paddle_status == closed && culvert_status == closed)
			-> startOpenCulvert.Lock(culvert_status = opening, w_level = between)
		<> (culvert_status == opening)
			-> culvertOpened.Lock(culvert_status = open)
		<> (culvert_status == open)
			-> detectWaterTop.Lock(w_level = top)
		<> (w_level == top && top_i_light == red && top_g_status == closed)
			-> startOpenTopGate.Lock(top_g_status = opening)
		<> (top_g_status == opening) 
			-> topGateOpened.Lock(top_g_status = opened)
		<> (top_g_status == opened && top_o_light == red)
			-> sendTOLight.Lock(top_o_light = green)
		<> (top_g_status == opened && top_o_light == green)
			-> upBoatExit.Lock(top_boat_moving = exit, top_o_light = red)
		<> (top_boat_moving = exit)
			-> upBoatExited.Lock(top_boat_moving = none, boat_present = empty)
%%then close gates i think?


proc BoatController(top_waiting: Nat, bottom_waiting: Nat, l_1_busy:LockBusy, l_2_busy:LockBusy) = 
	sum i:LockNr.receiveAvailable(i).
		((i == 1)
			-> BoatController(l_1_busy = available)
		 <> (i == 2)
			-> BoatController(l_2_busy = available))
	+
	(top_waiting <= 3)
		-> arriveTop.BoatController(top_waiting + 1) 
	+
	(bottom_waiting <= 3)
		-> arriveBottom.BoatController(bottom_waiting + 1) 
	+
	(top_waiting > 0) % if boats waiting at top, we ask that they can enter a lock
		-> sum i:LockNr.sendDownBoatRequest(i, enter).
			(controlDownBoatEnter.BoatController(top_waiting - 1) + % enter lock if can communicate
			BoatController())
	

init allow( {},
	 comm( {sendDownBoatRequest|receiveDownBoatRequest -> commDownBoat,
			controlDownBoatEnter|receiveDownBoatEnter -> commDBEnter,
			sendAvailable|receiveAvailable -> commAvailable,
			}, Lock||BoatController(0,0, available, available)));
			